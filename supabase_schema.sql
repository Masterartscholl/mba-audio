-- Create Categories Table
create table public.categories (
  id bigint generated by default as identity primary key,
  name text not null unique,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create Genres Table
create table public.genres (
  id bigint generated by default as identity primary key,
  name text not null,
  category_id bigint references public.categories(id) on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique (name, category_id)
);

-- Create Modes Table (Optional but good for structure)
create table public.modes (
    id bigint generated by default as identity primary key,
     name text not null unique,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable Row Level Security (RLS)
alter table public.categories enable row level security;
alter table public.genres enable row level security;
alter table public.modes enable row level security;

-- Create Policies (Public Read, Authenticated Write)
create policy "Public categories are viewable by everyone."
  on public.categories for select
  using ( true );

create policy "Authenticated users can insert categories."
  on public.categories for insert
  with check ( auth.role() = 'authenticated' );
  
create policy "Authenticated users can delete categories."
  on public.categories for delete
  using ( auth.role() = 'authenticated' );

create policy "Public genres are viewable by everyone."
  on public.genres for select
  using ( true );

create policy "Authenticated users can insert genres."
  on public.genres for insert
  with check ( auth.role() = 'authenticated' );

create policy "Authenticated users can delete genres."
  on public.genres for delete
  using ( auth.role() = 'authenticated' );
  
create policy "Public modes are viewable by everyone."
    on public.modes for select
    using ( true );

-- Seed Data (Initial Data)
insert into public.categories (name) values
  ('Beat'),
  ('Sosyal Medya'),
  ('Film Müzikleri'),
  ('Besteler');

-- Insert Genres dynamically (assuming IDs, but in SQL editor you might do this manually or with subqueries)
-- Example for 'Beat' (assuming ID 1)
insert into public.genres (name, category_id)
select 'Trap', id from public.categories where name = 'Beat'
union all
select 'Drill', id from public.categories where name = 'Beat'
union all
select 'Afro', id from public.categories where name = 'Beat';

-- Example for 'Sosyal Medya'
insert into public.genres (name, category_id)
select 'Hareketli', id from public.categories where name = 'Sosyal Medya'
union all
select 'Slow', id from public.categories where name = 'Sosyal Medya'
union all
select 'Marka', id from public.categories where name = 'Sosyal Medya';

-- Example for 'Film Müzikleri'
insert into public.genres (name, category_id)
select 'Aksiyon', id from public.categories where name = 'Film Müzikleri'
union all
select 'Gerilim', id from public.categories where name = 'Film Müzikleri'
union all
select 'Komedi', id from public.categories where name = 'Film Müzikleri';

-- Example for 'Besteler'
insert into public.genres (name, category_id)
select 'Pop Slow', id from public.categories where name = 'Besteler'
union all
select 'Pop Hareketli', id from public.categories where name = 'Besteler';
-- Create Tracks Table
create table public.tracks (
  id bigint generated by default as identity primary key,
  title text not null,
  category_id bigint references public.categories(id) on delete set null,
  genre_id bigint references public.genres(id) on delete set null,
  bpm integer,
  mode text,
  preview_url text, -- For watermarked preview
  master_url text,  -- For master file
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for tracks
alter table public.tracks enable row level security;

-- Policies for tracks
create policy "Public tracks are viewable by everyone."
  on public.tracks for select
  using ( true );

create policy "Authenticated users can insert tracks."
  on public.tracks for insert
  with check ( auth.role() = 'authenticated' );

create policy "Authenticated users can update tracks."
  on public.tracks for update
  using ( auth.role() = 'authenticated' );

create policy "Authenticated users can delete tracks."
  on public.tracks for delete
  using ( auth.role() = 'authenticated' );
-- Create Profiles Table
create table public.profiles (
  id uuid references auth.users(id) on delete cascade primary key,
  email text,
  is_admin boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for profiles
alter table public.profiles enable row level security;

-- Policies for profiles
create policy "Public profiles are viewable by everyone."
  on public.profiles for select
  using ( true );

create policy "Users can update their own profile."
  on public.profiles for update
  using ( auth.uid() = id );

-- Trigger to create profile on signup
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, is_admin)
  values (new.id, new.email, false); -- Default to false
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
